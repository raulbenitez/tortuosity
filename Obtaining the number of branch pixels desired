def howmanypixels(branch):
    l=0
    for i in range(len(branch)):
        for j in range(len(branch)):
            if branch[i][j]==1:
                l+=1
    return l
-----------------------------------------------------------------------------------------------------------------------------
# Create a table with the computed measure of the Tortuosity
def table (branch):
    pixel_graph, coordinates, degrees = skeleton_to_csgraph(branch,unique_junctions=False)
    branch_data = summarize(Skeleton(branch, spacing=pixspac))    
    branch_data['Tortuosity_1'] = branch_data.apply(lambda row: row['branch-distance']/row['euclidean-distance'], axis=1) # Old measure
    branch_data['Tortuosity_2'] = branch_data.apply(lambda row: row['branch-distance'] - row['euclidean-distance'], axis=1) # New measure
    return branch_data
-----------------------------------------------------------------------------------------------------------------------------    
def getcoordinates(branch):
    pixel_graph, coordinates, degrees = skeleton_to_csgraph(branch,unique_junctions=False)
    return coordinates
-----------------------------------------------------------------------------------------------------------------------------    
# For the infrarenal Aorta artery
# Deciding which pixels are vertically aligned and which pixels are diagonally aligned 
dstdiagonal=np.sqrt((pixspac**2)+(pixspac**2)) # diagonal distance in mm between the pixels of the image where pixspac is the space between the centers of neighboring pixels
def type_of_neighborsaorta(branch,c):
    branchcoordinates=getcoordinates(branch)
    vertical=[]
    diagonal=[]
    l=c
    index=np.arange(len(branchcoordinates)-1,1,-1) # We turn around the coordinates vector to star the process at the bottom.
    for i in index:
        dx1=(branchcoordinates[i-1][0]-branchcoordinates[i][0])**2
        dx2=(branchcoordinates[i-1][1]-branchcoordinates[i][1])**2
        dst=np.sqrt(dx1+dx2)
        round(dst,4)
        
        if dst==np.sqrt(2): #if it is square root of 2 it means boths pixels are into a diagonal line
            if l>0:
                l-=dstdiagonal
                diagonal.append([branchcoordinates[i-1][0],branchcoordinates[i-1][1]])
                diagonal.append([branchcoordinates[i][0],branchcoordinates[i][1]])
            
        elif dst==1: #if it is 1 it means 1 pixel is above the other
            if l>0:
                l-=pixspac
                vertical.append([branchcoordinates[i-1][0],branchcoordinates[i-1][1]])
                vertical.append([branchcoordinates[i][0],branchcoordinates[i][1]])
    return vertical,diagonal,l
  -----------------------------------------------------------------------------------------------------------------------------
# For the Iliac arteries
# Deciding which pixels are vertically aligned and which pixels are diagonally aligned  

 def type_of_neighborsiliac(branch,c):
    branchcoordinates=getcoordinates(branch)
    vertical=[]
    diagonal=[]
    l=c
    
    for i in range(1,len(branchcoordinates)):
        dx1=(branchcoordinates[i-1][0]-branchcoordinates[i][0])**2
        dx2=(branchcoordinates[i-1][1]-branchcoordinates[i][1])**2
        dst=np.sqrt(dx1+dx2)
        round(dst,4)
        
        if dst==np.sqrt(2): #if it is square root of 2 it means boths pixels are into a diagonal line
            if l>0:
                l-=dstdiagonal
                diagonal.append([branchcoordinates[i-1][0],branchcoordinates[i-1][1]])
                diagonal.append([branchcoordinates[i][0],branchcoordinates[i][1]])
            
        elif dst==1: #if it is 1 it means 1 pixel is above the other
            if l>0:
                l-=pixspac
                vertical.append([branchcoordinates[i-1][0],branchcoordinates[i-1][1]])
                vertical.append([branchcoordinates[i][0],branchcoordinates[i][1]])
        elif 2<dst<3:
            if l>0:
                l-=dstdiagonal
                diagonal.append([branchcoordinates[i-1][0],branchcoordinates[i-1][1]])
                diagonal.append([branchcoordinates[i][0],branchcoordinates[i][1]])
    return vertical,diagonal,l
 -----------------------------------------------------------------------------------------------------------------------------   
# we create a function that classifies the pixels of the segment under study in 2 lists, according to whether they are 
# diagonally or vertically to their previous neighbour. We can also set the exact desired distance of the branch 

# For the Aorta
def setlength_aorta(branch):
    indexi=np.arange(branch.shape[0]-1,0,-1) #we will start checking the image from the botom of the image to get the first 11 cm
    indexj=np.arange(branch.shape[0]-1,0,-1)
    vertical=type_of_neighborsaorta(branch,100)[0]
    diagonal=type_of_neighborsaorta(branch,100)[1]
    for i in indexi:
        for j in indexj:
                if [i,j] in vertical:
                    if i<position[0]:
                        branch[i][j]=1
                elif [i,j] in diagonal:
                    if i<position[0]:
                        branch[i][j]=1
                else:
                    branch[i][j]=0
    return branch
    
# For the Iliac  
def setlength_iliac(branch):
    vertical=type_of_neighborsiliac(branch,50)[0]
    diagonal=type_of_neighborsiliac(branch,50)[1]
    for i in range(len(branch)):
        for j in range(len(branch)):
            if [i,j] in vertical:
                    branch[i][j]=1
            elif [i,j] in diagonal:
                    branch[i][j]=1
            else:
                branch[i][j]=0
    return branch  
 -----------------------------------------------------------------------------------------------------------------------------
# Function to represent the segment analyzed 
def represent(branch):
    fig, ax = plt.subplots(figsize=(10,10))
    draw.overlay_skeleton_2d(l[2], branch, dilate=1, axes=ax)
    plt.title('Tortuosity:{}, Length:{} mm'.format(round(table(branch)['Tortuosity_2'][0],4),round(table(branch)['branch-distance'][0],2)), fontsize=20)
    plt.show()  
  
  
  
  
  
  
